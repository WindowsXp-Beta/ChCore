# Lab2: 内存管理

> author：魏新鹏
>
> student ID：519021910888

## 思考题 1

**请思考多级⻚表相⽐单级⻚表带来的优势和劣势（如果有的话），并计算在 AArch64 ⻚表中分别
以 4KB 粒度和 2MB 粒度映射 0～4GB 地址范围所需的物理内存⼤⼩（或⻚表⻚数量）。**

pros：

1. 多级页表从从两个方面减少了内存要求
   1. 如果前一级页表中的一个PTE是空的，那么后一级页表根本就不会存在。这代表了一种潜在的巨大节约，因为对很多程序来说，虚拟地址使用的比例都是很低的。
   2. 只有一级页表才需要总是在主存中，OS可以在需要时创建，调入调出二级页表，这减少了主存的压力。

cons：

1. 多级页表相比一级页表，增加了访存次数。但实际上由于TLB的作用，它能够缓存不同层次上页表的PTE，因此多级页表的翻译并不比单级页表慢很多（ref：《CS:APP(zh)》P573）

4kb：

L0: $1$	L1: $4$	L2: $4*512$	L3: $4*512^2$

页表页数量：1050629

所需物理内存大小：1050629 bytes $\approx$ 8 Mb

2Mb:

L0: $1$	L2: $4$	L2: $4*512$

页表页数量：2053

所需物理内存大小：16424 bytes $\approx$ 16 Kb

## 练习题 2

**请在 init_boot_pt 函数的 LAB 2 TODO 1 处配置内核⾼地址⻚表（ boot_ttbr1_l0 、 boot_ttbr1_l1 和 boot_ttbr1_l2 ），以 2MB 粒度映射。**

该处的代码思路参考给出的`TTBR0_EL1`的配置即可很方便的完成。具体见`mmu.c`。

## 思考题 3

**请思考在 init_boot_pt 函数中为什么还要为低地址配置⻚表，并尝试验证⾃⼰的解释。**

因为此时启动程序`init_c`，`el1_mmu_activate`等还运行在低地址端，如果不配置低地址段的页表，启动MMU后程序会如同lab1一样陷入0x200。将低地址配置页表的代码注释之后运行，果然又在0x200地址出无限重复跳转。

> 倘若只配置低地址，则在调用start_kernel后，则陷入0x200

## 练习题4&5&6

具体实现见代码。

## 思考题7

需要设置该虚拟页是否可写的权限位AP，以及DBM（(Dirty Bit Modifier) ）位。发生缺页异常时，CPU同样把控制流传递给操作系统预先设置的缺页异常处理函数，然后会发现是因为写了只读内存，并且此时该内存区域是被标记为写时拷贝的，然后操作系统会将其拷贝一份，并把权限改为可读可写重新映射给应用程序。

## 思考题8

由于页表粒度过大，不同区段之间的权限相同，不利于内核管理，无法体现不同分区不同的权限。
